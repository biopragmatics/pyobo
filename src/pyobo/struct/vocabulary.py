"""Reusable vocabulary."""

from collections.abc import Sequence

import curies
from curies import vocabulary as _v

from .reference import Reference, default_reference

__all__ = [
    "equivalent_class",
    "has_contributor",
    "mapping_has_confidence",
    "mapping_has_justification",
]

RO_PREFIX = "RO"
BFO_PREFIX = "BFO"


def _c(c: curies.Reference) -> Reference:
    if isinstance(c, curies.NamableReference):
        return Reference(prefix=c.prefix, identifier=c.identifier, name=c.name)
    else:
        return Reference(prefix=c.prefix, identifier=c.identifier)


broad_match = _c(_v.broad_match)
close_match = _c(_v.close_match)
exact_match = _c(_v.exact_match)
narrow_match = _c(_v.narrow_match)
related_match = _c(_v.related_match)

has_related_synonym = _c(_v.has_related_synonym)
has_exact_synonym = _c(_v.has_exact_synonym)
has_narrow_synonym = _c(_v.has_narrow_synonym)
has_broad_synonym = _c(_v.has_broad_synonym)

mapping_has_justification = Reference(
    prefix="sssom", identifier="mapping_justification", name="mapping justification"
)
mapping_has_confidence = Reference(prefix="sssom", identifier="confidence", name="has confidence")
has_contributor = _c(_v.has_contributor)
has_source = _c(_v.has_source)
has_date = _c(_v.has_date)
has_dbxref = _c(_v.has_dbxref)

in_subset = _c(_v.obo_in_subset)
has_obo_namespace = _c(_v.obo_has_namespace)
obo_is_metadata_tag = Reference(
    prefix="oboinowl", identifier="is_metadata_tag", name="is metadata tag"
)
obo_has_id = Reference(prefix="oboinowl", identifier="id", name="has ID")
obo_has_format_version = Reference(
    prefix="oboinowl", identifier="hasOBOFormatVersion", name="has OBO format version"
)
obo_autogenerated_by = _c(_v.obo_autogenerated_by)
obo_creation_date = _c(_v.obo_creation_date)

equivalent_class = _c(_v.equivalent_property)
equivalent_property = _c(_v.equivalent_class)
owl_same_as = _c(_v.same_as)
version_info = _c(_v.owl_version_info)
term_replaced_by = _c(_v.term_replaced_by)
alternative_term = _c(_v.alternative_term)
has_ontology_root_term = _c(_v.has_ontology_root_term)
has_term_editor = _c(_v.has_term_editor)

see_also = _c(_v.see_also)
comment = _c(_v.has_comment)
label = _c(_v.has_label)

from_species = Reference(prefix=RO_PREFIX, identifier="0002162", name="in taxon")
species_specific = Reference(prefix="debio", identifier="0000007", name="species specific")
has_left_to_right_reaction = Reference(
    prefix="debio", identifier="0000007", name="has left-to-right reaction"
)
has_right_to_left_reaction = Reference(
    prefix="debio", identifier="0000008", name="has right-to-left reaction"
)
debio_has_inchi = Reference(prefix="debio", identifier="0000020", name="has InChI")
has_inchi = Reference(prefix="chemrof", identifier="inchi_string")

debio_has_smiles = Reference(prefix="debio", identifier="0000022", name="has SMILES")
has_smiles = Reference(prefix="chemrof", identifier="smiles_string")

# TODO update to use debio, or put in RO
has_citation = default_reference(prefix="RO", identifier="hasCitation", name="has citation")
has_description = _c(_v.has_description)
has_license = _c(_v.has_license)
has_title = _c(_v.has_title)

has_part = Reference(prefix=BFO_PREFIX, identifier="0000051", name="has part")
part_of = Reference(prefix=BFO_PREFIX, identifier="0000050", name="part of")
orthologous = Reference(
    prefix=RO_PREFIX, identifier="HOM0000017", name="in orthology relationship with"
)
is_a = _c(_v.is_a)
subproperty_of = _c(_v.subproperty_of)
rdf_type = _c(_v.rdf_type)

xsd_string = _c(_v.xsd_string)
xsd_float = _c(_v.xsd_float)
xsd_decimal = _c(_v.xsd_decimal)
xsd_integer = _c(_v.xsd_integer)
xsd_boolean = _c(_v.xsd_boolean)
xsd_year = _c(_v.xsd_year)
xsd_uri = _c(_v.xsd_uri)

CHARLIE = _c(_v.charlie)
HUMAN = _c(_v.human)

#: See https://mapping-commons.github.io/sssom/spec-model/
match_typedefs: Sequence[Reference] = (
    broad_match,
    close_match,
    exact_match,
    narrow_match,
    related_match,
    owl_same_as,  # for instances
    equivalent_class,  # for classes
    equivalent_property,  # for properties
    has_dbxref,
    see_also,
)

# Extension past the SSSOM spec
extended_match_typedefs: Sequence[Reference] = (
    *match_typedefs,
    alternative_term,
    term_replaced_by,
)

#: These are predicates that have their own dedicated fields
#: in OBO and FunOWL output
SKIP_PROPERTY_PREDICATES_OBJECTS = [
    term_replaced_by,  # maps to "replaced_by:" line
    see_also,  # maps to "consider:" line
    alternative_term,  # maps to "alt_id:" line
]

SKIP_PROPERTY_PREDICATES_LITERAL = [
    comment,  # maps to "comment:" line with strings
    obo_creation_date,
]
