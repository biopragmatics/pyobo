"""Import of OBO Graph JSON."""

import logging
from pathlib import Path

import curies
import obographs
from curies import Converter
from curies.vocabulary import SynonymScope, synonym_scopes
from obographs import (
    Graph,
    NodeType,
    StandardizedGraph,
    StandardizedMeta,
    StandardizedNode,
    StandardizedSynonym,
)

from pyobo import Obo, Reference, StanzaType, Synonym, Term, TypeDef
from pyobo.identifier_utils import get_converter
from pyobo.struct import Annotation, OBOLiteral, make_ad_hoc_ontology
from pyobo.struct import vocabulary as v
from pyobo.struct.typedef import has_ontology_root_term

__all__ = [
    "from_node",
    "from_obograph",
    "from_standardized_graph",
    "read_obograph",
]

logger = logging.getLogger(__name__)


def read_obograph(
    prefix: str, path: str | Path, *, converter: Converter | None = None, strict: bool = False
) -> Obo:
    """Read an OBO Graph JSON file using :func:`obographs.read` then process into a PyOBO structure."""
    graph = obographs.read(path, squeeze=True)
    return from_obograph(prefix=prefix, graph=graph, converter=converter, strict=strict)


def from_obograph(
    prefix: str, graph: Graph, *, converter: Converter | None = None, strict: bool = False
) -> Obo:
    """Parse a raw OBO Graph JSON into a PyOBO structure."""
    if converter is None:
        converter = get_converter()
    standardized_graph = graph.standardize(converter, strict=strict)
    return from_standardized_graph(prefix, standardized_graph)


def from_standardized_graph(prefix: str, graph: StandardizedGraph) -> Obo:
    """Generate an OBO data structure from OBO Graph JSON."""
    terms: dict[Reference, Term] = {}
    typedefs: dict[Reference, TypeDef] = {}
    for node in graph.nodes:
        stanza = from_node(node)
        match stanza:
            case Term():
                terms[stanza.reference] = stanza
            case TypeDef():
                typedefs[stanza.reference] = stanza

    for edge in graph.edges:
        s, p, o = (Reference.from_reference(r) for r in (edge.subject, edge.predicate, edge.object))
        if s in terms:
            stanza = terms[s]
            stanza.append_relationship(p, o)
        elif s in typedefs:
            stanza = typedefs[s]
            stanza.append_relationship(p, o)

    root_terms: list[Reference] = []
    property_values = []
    auto_generated_by: str | None = None
    if graph.meta:
        for prop in graph.meta.properties or []:
            predicate = Reference.from_reference(prop.predicate)
            if predicate == has_ontology_root_term:
                if isinstance(prop.value, str):
                    raise TypeError
                else:
                    root_terms.append(Reference.from_reference(prop.value))
            elif predicate == v.obo_autogenerated_by:
                if not isinstance(prop.value, str):
                    raise TypeError
                auto_generated_by = prop.value
            # TODO specific subsetdef, imports
            else:
                property_values.append(
                    Annotation(
                        predicate=predicate,
                        # TODO obographs are limited by ability to specify datatype?
                        value=OBOLiteral.string(prop.value)
                        if isinstance(prop.value, str)
                        else Reference.from_reference(prop.value),
                    )
                )

    for equivalent_node_set in graph.equivalent_node_sets:
        equivalent_reference = Reference.from_reference(equivalent_node_set.node)
        if equivalent_reference in terms:
            for equivalent in equivalent_node_set.equivalents:
                terms[equivalent_reference].append_equivalent_to(
                    Reference.from_reference(equivalent)
                )
        elif equivalent_reference in typedefs:
            for equivalent in equivalent_node_set.equivalents:
                typedefs[equivalent_reference].append_equivalent_to(
                    Reference.from_reference(equivalent)
                )
        else:
            logger.warning(
                "unknown reference node in equivalent_node_set: %s", equivalent_reference.curie
            )

    for _domain_range_axiom in graph.domain_range_axioms or []:
        p = Reference.from_reference(_domain_range_axiom.predicate)
        if p not in typedefs:
            continue
        # the OBO Graph model allows for multiple ranges
        # or domains, but OBO only one.
        if _domain_range_axiom.ranges:
            typedefs[p].range = Reference.from_reference(_domain_range_axiom.ranges[0])
        if _domain_range_axiom.domains:
            typedefs[p].domain = Reference.from_reference(_domain_range_axiom.domains[0])

    for _property_chain_axiom in graph.property_chain_axioms:
        p = Reference.from_reference(_property_chain_axiom.predicate)
        if p not in typedefs or not _property_chain_axiom.chain:
            continue
        # TODO check if its also transitive_over and/or equivalent_to_chain
        typedefs[p].holds_over_chain.append(
            [Reference.from_reference(r) for r in _property_chain_axiom.chain]
        )

    for _logical_definition_axiom in graph.logical_definition_axioms:
        pass  # TODO

    return make_ad_hoc_ontology(
        _ontology=prefix,
        _name=graph.name,
        terms=list(terms.values()),
        _typedefs=list(typedefs.values()),
        _root_terms=root_terms,
        _property_values=property_values,
        _data_version=graph.version or (graph.meta.version_iri if graph.meta is not None else None),
        _auto_generated_by=auto_generated_by,
    )


#: A mapping between OBO Graph JSON node types and OBO stanza types
MAPPING: dict[NodeType, StanzaType] = {
    "CLASS": "Term",
    "INDIVIDUAL": "Instance",
    "PROPERTY": "TypeDef",
}


def from_node(node: StandardizedNode) -> Term | TypeDef:
    """Generate a term from a node."""
    if node.type == "PROPERTY":
        return _from_property(node)
    return _from_term(node)


def _from_term(node: StandardizedNode) -> Term:
    term = Term(
        reference=_get_ref(node),
        type=MAPPING[node.type] if node.type else "Term",
    )
    if node.meta is not None:
        _process_term_meta(node.meta, term)
    return term


def _from_property(node: StandardizedNode) -> TypeDef:
    typedef = TypeDef(
        reference=_get_ref(node),
        is_metadata_tag=node.property_type == "ANNOTATION",
    )
    if node.meta is not None:
        _process_typedef_meta(node.meta, typedef)
    return typedef


def _get_ref(node: StandardizedNode) -> Reference:
    return Reference(
        prefix=node.reference.prefix,
        identifier=node.reference.identifier,
        name=node.label,
    )


def _process_term_meta(meta: StandardizedMeta, term: Term) -> None:
    """Process the ``meta`` object associated with a term node."""
    if meta.definition:
        term.definition = meta.definition.value
        for definition_xref in meta.definition.xrefs or []:
            term.append_definition_xref(definition_xref)

    if meta.subsets:
        term.subsets.extend(Reference.from_reference(r) for r in meta.subsets)

    for xref in meta.xrefs or []:
        term.append_xref(xref.reference)

    for synonym in meta.synonyms or []:
        if s := _from_synonym(synonym):
            term.append_synonym(s)

    for comment in meta.comments or []:
        term.append_comment(comment)

    if meta.deprecated:
        term.is_obsolete = True

    for prop in meta.properties or []:
        match prop.value:
            case Reference():
                term.annotate_object(prop.predicate, prop.value)
            case str():
                # note, OBO Graph format does not allow for annotating data type
                term.annotate_literal(prop.predicate, OBOLiteral.string(prop.value))


REV_SYNONYM_SCOPE: dict[curies.Reference, SynonymScope] = {v: k for k, v in synonym_scopes.items()}


def _from_synonym(syn: StandardizedSynonym) -> Synonym | None:
    return Synonym(
        name=syn.text,
        specificity=REV_SYNONYM_SCOPE[syn.predicate],
        type=Reference.from_reference(syn.type) if syn.type is not None else None,
        provenance=[Reference.from_reference(r) for r in syn.xrefs or []],
    )


def _process_typedef_meta(meta: StandardizedMeta, typedef: TypeDef) -> None:
    """Process the ``meta`` object associated with a property node."""
    # TODO everything else is in here
